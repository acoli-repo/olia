<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE rdf:RDF [
    <!ENTITY owl "http://www.w3.org/2002/07/owl#" >
    <!ENTITY olia_system "http://purl.org/olia/system.owl#" >
    <!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" >
    <!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" >
    <!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#" >
]>

<rdf:RDF
  xmlns:owl="http://www.w3.org/2002/07/owl#"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
  xmlns:oliasystem="http://purl.org/olia/system.owl#"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#compound_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#compound"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">compound</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#compound">
    <rdfs:label xml:lang="en-gb">compound</rdfs:label>
    <rdfs:label>compound</rdfs:label>
    <rdfs:comment xml:lang="en-gb">compound is one of the three relations in UD for compounding. It is used for any kind of X0 compounding: noun compounds (e.g., phone book), but also verb and adjective compounds that are more common in other languages (such as Persian or Japanese light verb constructions). It is also used for the “phrasal verb” construction of European languages (e.g., throw up), with the adposition as the compound dependent of the verb. Phone book compound(book, Phone) for numbers I have four thousand sheep compound(thousand, four) I lost $ 3.2 billion compound(billion, 3.2) for particles of phrasal verbs: put up compound(put, up) The two other compounding relations are:mwe for fixed grammaticized expressions with function words name for proper nouns constituted of multiple nominal elements</rdfs:comment>
    <rdfs:subClassOf>
      <rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#dep">
        <rdfs:label xml:lang="en-gb">Universal Dependencies</rdfs:label>
        <rdfs:label xml:lang="en-gb">unspecified dependency</rdfs:label>
        <rdfs:label>dep</rdfs:label>
        <rdfs:comment xml:lang="en-gb">A dependency is labeled as dep when a system is unable to determine a more precise dependency relation between two words. This may be because of a weird grammatical construction, a limitation in software (e.g. the Stanford Dependency conversion), a parser error, or because of an unresolved long distance dependency. Then , as if to show that he could , ... dep(show, if)</rdfs:comment>
        <rdfs:subClassOf>
          <owl:Restriction>
            <owl:hasValue>DEPREL</owl:hasValue>
            <owl:onProperty rdf:resource="oliasystem:hasTier"/>
          </owl:Restriction>
        </rdfs:subClassOf>
        <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
      </rdf:Description>
    </rdfs:subClassOf>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#acl_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#acl"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">acl</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#acl">
    <rdfs:label xml:lang="en-gb">clausal modifier of noun (adjectival clause)</rdfs:label>
    <rdfs:label>acl</rdfs:label>
    <rdfs:comment xml:lang="en-gb">acl stands for finite and non-finite clauses that modify a nominal. The acl relation contrasts with theadvcl relation, which is used for adverbial clauses that modify a predicate. The head of the acl relation is the noun that is modified, and the dependent is the head of the clause that modifies the noun. the issues as he sees them acl(issues, sees) Cette affaire à suivre \n This case to follow acl(affaire, suivre) This relation is also used for optional depictives. The adjective is taken to modify the nominal of which it provides a secondary predication. See xcomp for further discussion of resultatives and depictives. She entered the room sad acl(She, sad) He painted the model naked acl(model, naked) A relative clause is an instance of acl, characterized by finiteness and usually omission of the modified noun in the embedded clause. Some languages use a language-particular subtype for the traditional class of relative clauses. I saw the man you love acl(man, love) Some languages allow finite clausal complements for nouns with a subset of nouns like fact or report. These look roughly like relative clauses, but do not have any omitted role in the dependent clause. This is the class of “content clauses” in Huddleston and Pullum 2002). These are also analyzed as acl. the fact that nobody cares acl(fact, cares)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#dobj_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dobj"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">dobj</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#dobj">
    <rdfs:label xml:lang="en-gb">direct object</rdfs:label>
    <rdfs:label>dobj</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The direct object of a verb is the second most core argument of a verb after the subject. Typically, it is the noun phrase that denotes the entity acted upon or which undergoes a change of state or motion (the proto-patient). She gave me a raise dobj(gave, raise)In languages distinguishing morphologicalcases, the direct object will often be marked by the accusative case. However, verb valency may occasionally dictate a different form, such as the dative case in the following German example: jemandem begegnen \n someone.Dat to-meet dobj(begegnen, jemandem) In general, if there is just one object, it should be labeled dobj, regardless of the morphological case or semantic role that it bears. If there are two or more objects, one of them should be dobj and the others should be iobj. In such cases it is necessary to decide what is the most directly affected object (patient). The one exception is when there is a clausal complement. Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj. There is more discussion of constructions with multiple objects on the page for iobj. If possible, language-specific documentation should be available to help identify direct objects.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#mwe_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#mwe"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">mwe</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#mwe">
    <rdfs:label>mwe</rdfs:label>
    <rdfs:label xml:lang="en-gb">multi-word expression</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The multi-word expression (modifier) relation is one of the three relations (compound, mwe, name) for compounding. It is used for certain fixed grammaticized expressions that behave like function words or short adverbials. The scope of mwe annotation corresponds roughly to the fixed expressions category of Sag et al., but excludes any relations in scope of name or compound. Additionally, limited morphosyntactic variation may be allowed for MWEs in exceptional cases. I like dogs as well as cats mwe(as-4, well-5) mwe(as-4, as-6) He cried because of you mwe(because, of) Je préfère prendre un dessert plutôt qu' une entrée \n I prefer getting a dessert rather than an appetizer mwe(plutôt, qu') Multiword expressions are annotated in a flat, head-initial structure, in which all words in the expression modify the first one using the mwe label.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#csubj_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#csubj"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">csubj</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#csubj">
    <rdfs:label xml:lang="en-gb">clausal subject</rdfs:label>
    <rdfs:label>csubj</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A clausal subject is a clausal syntactic subject of a clause, i.e., the subject is itself a clause. The governor of this relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb. The dependent is the main lexical verb or other predicate of the subject clause. In the following example, what she said (that is, said is the clausal subject of makes. What she said makes sense csubj(makes, said)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#conj_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#conj"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">conj</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#conj">
    <rdfs:label xml:lang="en-gb">conjunct</rdfs:label>
    <rdfs:label>conj</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A conjunct is the relation between two elements connected by a coordinating conjunction, such as and, or, etc. We treat conjunctions asymmetrically: The head of the relation is the first conjunct and all the other conjuncts depend on it via the conj relation. Bill is big and honest conj(big, honest) We have apples , pears , oranges , and bananas . dobj(have, apples) conj(apples, pears) conj(apples, oranges) conj(apples, bananas) cc(apples, and) punct(apples, ,-4) punct(apples, ,-6) punct(apples, ,-8) Coordinate clauses are treated the same way as coordination of other constituent types: He came home , took a shower and immediately went to bed . conj(came, took) conj(came, went) punct(came, ,-4) cc(came, and) Coordination may be asyndetic, which means that the coordinating conjunction is omitted. Commas or other punctuation symbols will delimit the conjuncts in the typical case. Asyndetic coordination may be more frequent in some languages, while in others, conjunction will appear between every two conjuncts (John and Mary and Bill). Veni , vidi , vici . conj(Veni, vidi) conj(Veni, vici) punct(Veni, ,-2) punct(Veni, ,-4) Shared Dependents and Effective Parents in Coordination Note that the current basic annotation scheme cannot distinguish between a dependent of the first conjunct and a shared dependent of the whole coordination: He met her at the station and kissed her . conj(met, kissed) nsubj(met, He) vs. He met her at the station and she kissed him . conj(met, kissed) nsubj(met, He) nsubj(kissed, she) In contrast, the additional dependencies in the enhanced representation can be used to encode the fact that in the first case, he is also subject of kissed: He met her at the station and kissed her . conj(met, kissed) nsubj(met, He) nsubj(kissed, He) Furthermore, the enhanced representation can also capture the relation of each conjunct to the parent of the coordination. Nevertheless, the effective parents can be found algorithmically and showing them explicitly is for convenience only, while the information about shared dependents is otherwise not available. I saw that he met her at the station and kissed her . conj(met, kissed) nsubj(met, he) nsubj(kissed, he) ccomp(saw, met) ccomp(saw, kissed) If a dependent is shared among conjuncts, the basic representation always links it to the first conjunct (coordination head). Relations to the other conjuncts are in the enhanced representation. In the following example, enhanced dependencies are shown in red: # visual-style 6 1 amod color:red # visual-style 4 3 amod color:red # visual-style 6 3 amod color:red 1 American _ _ _ _ 4 amod 6:amod _ 2 and _ _ _ _ 1 cc _ _ 3 British _ _ _ _ 1 conj 4:amod|6:amod _ 4 professors _ _ _ _ 0 root _ _ 5 and _ _ _ _ 4 cc _ _ 6 students _ _ _ _ 4 conj 0:root _ Nested Coordination Note further that the current annotation scheme has only a limited capability to capture nested coordination such as apples and pears or oranges and lemons. Consider coordinations A, B, C (A, B), C A, (B, C) The first two cases, i.e. (A, B, C) and ((A, B), C), lead to the same tree: A B C conj(A, B) conj(A, C) Only the right-nesting case (A, (B, C)) can be distinguished because its tree is different: A B C conj(B, C) conj(A, B)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#aux_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#aux"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">aux</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#aux">
    <rdfs:label xml:lang="en-gb">auxiliary</rdfs:label>
    <rdfs:label>aux</rdfs:label>
    <rdfs:comment xml:lang="en-gb">An auxiliary of a clause is anon-main verb of the clause, e.g., a modal auxiliary, or a form of be, do or have in a periphrastic tense. Exception: Auxiliary verb used to construct the passive voice is not labeled aux but auxpass. Reagan has died aux(died-3, has-2) He should leave aux(leave-3, should-2) Do you think that he will have left when we come ? aux(think, Do) aux(left, will) aux(left, have)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#neg_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#neg"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">neg</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#neg">
    <rdfs:label xml:lang="en-gb">negation modifier</rdfs:label>
    <rdfs:label>neg</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The negation modifier is the relation between a negation word and the word it modifies. Modifiers labeled neg depend either on a noun (group “noun dependents”) or on a predicate (group “non-core dependents of clausal predicates”). Bill is not a scientist neg(scientist, not) Bill is no scientist neg(scientist, no) Bill does n't drive neg(drive, n't)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#remnant_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#remnant"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">remnant</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#remnant">
    <rdfs:label>remnant</rdfs:label>
    <rdfs:label xml:lang="en-gb">remnant in ellipsis</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The remnant relation is used to provide a satisfactory treatment of ellipsis (in the case of gapping and stripping, where a predicational or verbal head gets elided). This is something that was lacking in earlier versions of SD and provides a basis for being able to reconstruct dependencies in the enhanced representation of UD. In particular, the goal was to achieve this without having to postulate empty nodes in the basic representation. To develop motivation, consider first a sentence without ellipsis: Marie went to Paris and Miriam went to Prague nsubj(went-2, Marie-1) root(root-0, went-2) nmod(went-2, Paris-4) case(Paris-4, to-3) cc(went-2, and-5) nsubj(went-7, Miriam-6) conj(went-2, went-7) case(Prague-9, to-8) nmod(went-7, Prague-9) The question is then how to treat: Marie went to Paris and Miriam to Prague Marie went to Paris and Miriam to Prague nsubj(went-2, Marie-1) root(root-0, went-2) nmod(went-2, Paris-4) case(Paris-4, to-3) cc(went-2, and-5) case(Prague-8, to-7) One option would be to pretend that there is an empty verb and to have the final elements be dependents of it: Marie went to Paris and Miriam ∅ to Prague. This analysis has some appeal but also has some problems and at any rate stops the basic dependency graph from being simply a tree of dependencies over the words of a sentence. A second option is to simply promote the final elements and to have them as dependents of the main verb of the sentence (went-2) or of root-0. But then (in general) one loses the ability to successfully reconstruct the correct predicate-argument structure of the sentence from the basic dependency representation. Therefore, UD adopts an analysis that notes that in ellipsis a remnant corresponds to a correlate in a preceding clause. The remnant relation connects each remnant to its correlate in the basic dependency representation. This is then a sufficient representation to reconstruct the predicate-argument structure in the enhanced representation. So, for this example, we have: Marie went to Paris and Miriam to Prague nsubj(went-2, Marie-1) root(root-0, went-2) nmod(went-2, Paris-4) case(Paris-4, to-3) cc(went-2, and-5) remnant(Marie-1, Miriam-6) case(Prague-8, to-7) remnant(Paris-4, Prague-8) Even in the more complex example below, the remnant relations enable us to correctly retrieve the subjects and objects in the clauses with an elided verb. John won bronze , Mary silver , and Sandy gold nsubj(won-2, John-1) dobj(won-2, bronze-3) remnant(John-1, Mary-5) remnant(Mary-5, Sandy-9) remnant(bronze-3, silver-6) remnant(silver-6, gold-10)Note in particular that (unlike forconj), remnant uses a chaining analysis where each subsequent remnant depends on the immediately preceding remnant/correlate. The reason for this is that otherwise in a sentence with 2 or more chained ellipses the dependency structure would no longer track which remnants go together. It would become impossible to determine whether Mary won silver and Sandy gold, or Mary won gold and Sandy silver. It is also possible that the incomplete part precedes the complete one in the sentence [de]: während 78 Prozent sich für Bush und vier Prozent für Clinton aussprachen \n while 78 percent REFL for Bush and four percent for Clinton spoke-out nsubj(aussprachen, Prozent-9) nsubj(spoke-out, percent-22) nmod(aussprachen, Clinton-11) nmod(spoke-out, Clinton-24) remnant(Prozent-9, Prozent-3) remnant(percent-22, percent-16) remnant(Clinton-11, Bush-6) remnant(Clinton-24, Bush-19) The remnant relation is used when no predicational material is present. In contrast, in right-node-raising (RNR) and VP-ellipsis constructions in which some kind of predicational or verbal material is still present, the remnant relation is not used. In RNR, the verbs are coordinated and the object is a dobj of the first verb: John bought and ate an apple nsubj(bought-2, John-1) cc(bought-2, and-3) conj(bought-2, ate-4) det(apple-6, an-5) dobj(bought-2, apple-6) In VP-ellipsis, we keep the auxiliary as the head, as shown below: John will win gold and Mary will too nsubj(win-3, John-1) aux(win-3, will-2) dobj(win-3, gold-4) cc(win-3, and-5) conj(win-3, will-7) nsubj(will-7, Mary-6) advmod(will-7, too-8)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#auxpass_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#auxpass"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">auxpass</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#auxpass">
    <rdfs:label xml:lang="en-gb">passive auxiliary</rdfs:label>
    <rdfs:label>auxpass</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A passive auxiliary of a clause is a non-main verb of the clause which contains the passive information. Kennedy has been killed auxpass(killed, been) Kennedy was killed auxpass(killed, was) Kennedy got killed auxpass(killed, got)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#ccomp_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#ccomp"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">ccomp</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#ccomp">
    <rdfs:label xml:lang="en-gb">clausal complement</rdfs:label>
    <rdfs:label>ccomp</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A clausal complement of a verb or adjective is a dependent clause which is a core argument. That is, it functions like an object of the verb, or adjective. He says that you like to swim ccomp(says, like) mark(like, that) He says you like to swim ccomp(says, like)Such clausal complements may be finite or nonfinite. However, if the subject of the clausal complement is controlled (that is, must be the same as the higher subject or object, with no other possible interpretation) the appropriate relation isxcomp. The boss said to start digging ccomp(said, start) mark(start, to) We started digging xcomp(started, digging) The key difference here is that, while it is possible to interpret the first sentence to mean that the boss will not be doing any digging, in the second sentence it is clear that the subject of digging can only be we. This is what distinguishes ccomp and xcomp. Additionally, ccomp is used with copulas. The important thing is to keep calm. ccomp(is, keep) The problem is that this has never been tried . ccomp(is, tried) (In these cases, the copula is treated as a head. This is a somewhat inconsistent and ugly feature of the current UD. An alternative solution was adopted for this case in the Turku TDT. It may be worth considering adopting it in a revision of UD.) Note: In earlier versions of SD/USD, complement clauses with nouns like fact or report were also analyzed as ccomp. However, we now analyze them as acl. Hence, ccomp does not appear in nominals. This makes sense, since nominals normally do not take core arguments.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#foreign_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#foreign"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">foreign</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#foreign">
    <rdfs:label>foreign</rdfs:label>
    <rdfs:label xml:lang="en-gb">foreign words</rdfs:label>
    <rdfs:comment xml:lang="en-gb">We use foreign to label sequences of foreign words. These are given a linear analysis: the head is the first token in the foreign phrase.foreign does not apply to loanwords or to foreignnames. It applies to quoted foreign text incorporated in a sentence/discourse of the host language (unless we want to and know how to annotate the internal structure according to the syntax of the foreign language). I guess that c' est la vie nsubj(guess-2, I-1) ccomp(guess-2, c'-4) mark(c'-4, that-3) foreign(c'-4, est-5) foreign(c'-4, la-6) foreign(c'-4, vie-7)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#case_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#case"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">case</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#case">
    <rdfs:label>case</rdfs:label>
    <rdfs:label xml:lang="en-gb">case marking</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The case relation is used for any case-marking element which is treated as a separate syntactic word (including prepositions, postpositions, and clitic case markers). Case-marking elements are treated as dependents of the noun or clause they attach to or introduce. (Thus, contrary to SD, UD abandons treating a preposition as a mediator between a modified word and its object.) The case relation aims at providing a more uniform analysis of nominal elements, prepositions and case in morphologically rich languages: a nominal in an oblique case will receive the same dependency structure as a nominal introduced by an adposition. the Chair 's office det(Chair-2, the-1) nmod(office-4, Chair-2) case(Chair-2, 's-3) the office of the Chair det(office-2, the-1) nmod(office-2, Chair-5) case(Chair-5, of-3) det(Chair-5, the-4) French: le bureau du président \n the office of the_Chair det(bureau, le) nmod(bureau, président) case(président, du) Hebrew: hwa/PRON rah/VERB at/PART[Case=Acc] h/DET klb/NOUN \n he saw ACC the dog dobj(rah-2, klb-5) case(klb-5, at-3)When case markers are morphemes, they are not divided off the noun as a separate case dependent, but the noun as a whole is analyzed as anmod of the verb. To overtly mark case, POS tags and features are included in the representation as shown below on a Russian example (put your mouse pointer over the words to see additional morphosyntactic features). # I wrote the letter with a quill. 1 Я ja PRON _ Case=Nom|Number=Sing|Person=1|PronType=Prs 2 nsubj _ I 2 написал napisat' VERB _ Gender=Masc|Number=Sing|VerbForm=Part|Voice=Act 0 root _ wrote 3 письмо pis'mo NOUN _ Case=Acc|Gender=Neut|Number=Sing 2 dobj _ the-letter 4 пером pero NOUN _ Case=Ins|Gender=Neut|Number=Sing 2 nmod _ with-a-quill This treatment provides parallelism between different constructions across and within languages. A good result is that we now have greater parallelism between prepositional phrases and subordinate clauses, which are often introduced by a preposition in some languages: Sue left after the rehearsal nsubj(left-2, Sue-1) nmod(left-2, rehearsal-5) det(rehearsal-5, the-4) case(rehearsal-5, after-3) Sue left after we did nsubj(left-2, Sue-1) advcl(left-2, did-5) mark(did-5, after-3) nsubj(did-5, we-4) We also obtain parallel constructions for the possessive alternation the Chair 's office det(Chair-2, the-1) nmod(office-4, Chair-2) case(Chair-2, 's-3) the office of the Chair det(office-2, the-1) nmod(office-2, Chair-5) case(Chair-5, of-3) det(Chair-5, the-4) variant forms with case, a preposition or a postposition in Finnish etsiä ilman johtolankaa \n to_search without clue.PARTITIVE nmod(etsiä, johtolankaa) case(johtolankaa, ilman) etsiä taskulampun kanssa \n to_search torch.GENITIVE with nmod(etsiä, taskulampun) case(taskulampun, kanssa) etsiä johtolangatta \n to_search clue.ABESSIVE nmod(etsiä, johtolangatta) the dative alternation where the prepositional construction gets a similar analysis to the double object construction give the children the toys dobj(give, toys) iobj(give, children) give the toys to the children dobj(give, toys) nmod(give, children) case(children, to) # give the toys to the children 1 donner donner VERB _ VerbForm=Inf 0 root _ give 2 les le DET _ Definite=Def|Number=Plur 3 det _ the 3 jouets jouet NOUN _ Gender=Masc|Number=Plur 1 dobj _ toys 4-5 aux _ _ _ _ _ _ _ _ 4 à à ADP _ _ 6 case _ to 5 les le DET _ Definite=Def|Number=Plur 6 det _ the 6 enfants enfant NOUN _ Gender=Masc|Number=Plur 1 nmod _ children Another advantage of this new analysis is that it provides a treatment of prepositional phrases that are predicative complements of “be” that is consistent with the treatment of nominal predicative complements: Sue is in shape nsubj(shape-4, Sue-1) cop(shape-4, is-2) case(shape-4, in-3) When prepositions are stacked (that is, there is a sequence of prepositions), there are two possible analyses. If the sequence is a frozen combination with a specific meaning, then the best analysis is as an mwe. An English example of this is out of: Out of all this , something good will come . case(this-4, Out-1) mwe(Out-1, of-2) det(this-4, all-3) nmod(come, this-4) However, if various combinations of prepositions can be used to express different meaning combinations or nuances, then each preposition is independently analyzed as a case dependent. Examples of this in English include up beside (which can alternate with down beside or up near) or except during which can alternate with as during or except after: The cafe up beside the lookout det(cafe-2, The-1) case(lookout-6, up-3) case(lookout-6, beside-4) det(lookout-6, the-5) nmod(cafe-2, lookout-6)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nsubj_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#nsubj"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">nsubj</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nsubj">
    <rdfs:label xml:lang="en-gb">nominal subject</rdfs:label>
    <rdfs:label>nsubj</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A nominal subject (nsubj) is a nominal which is the syntactic subject and the proto-agent of a clause. That is, it is in the position that passes typical grammatical test for subjecthood, and this argument is the more agentive, the do-er, or the proto-agent of the clause. (Seecsubj for when the subject is clausal. See nsubjpass and csubjpass for when the subject is not the proto-agent argument due to valence changing operations.) This nominal may be headed by a noun, or it may be a pronoun or relative pronoun, or in ellipsis contexts, other things such as an adjective. The nsubj role is only applied to semantic arguments of a predicate. When there is an empty argument in a grammatical subject position (sometimes called a pleonastic or expletive), it is labeled as expl. If there is then a displaced subject in the clause, as in the English existential there construction, it will be labeled as nsubj.) The governor of the nsubj relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb, which can be an adjective or noun, including a noun marked by a preposition, as in the examples below. Clinton defeated Dole nsubj(defeated, Clinton) The car is red . nsubj(red, car) Sue is a true patriot . nsubj(patriot, Sue) We are in the barn . nsubj(barn, We) Agatha is in trouble . nsubj(trouble, Agatha) There is a ghost in the room . expl(is, There) nsubj(is, ghost) These links present the many viewpoints that existed . acl(viewpoints, existed) nsubj(existed, that)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#mark_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#mark"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">mark</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#mark">
    <rdfs:label>mark</rdfs:label>
    <rdfs:label xml:lang="en-gb">marker</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A marker is the word introducing a finite clause subordinate to another clause. For acomplement clause, this is words like [en] that or whether. For an adverbial clause, the marker is typically a subordinating conjunction like [en] while or although. The mark is a dependent of the subordinate clause head. In a relative clause, it is a normally uninflected word, which simply introduces a relative clause, such as [he] še. (In this last use, one needs to distinguish between relative clause markers, which are mark from relative pronouns, which fill a regular verbal argument or modifier grammatical relation. Forces engaged in fighting after insurgents attacked mark(attacked, after) He says that you like to swim mark(swim, that) Er kam wieder , um das Werk zu Ende zu bringen \n He came again , so-that the work to end to bring mark(bringen, um) mark(bringen, zu-10) mark(bring, so-that) mark(bring, to-22)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#discourse_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#discourse"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">discourse</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#discourse">
    <rdfs:label>discourse</rdfs:label>
    <rdfs:label xml:lang="en-gb">discourse element</rdfs:label>
    <rdfs:comment xml:lang="en-gb">This is used forinterjections and other discourse particles and elements (which are not clearly linked to the structure of the sentence, except in an expressive way). We generally follow the guidelines of what the Penn Treebanks count as an INTJ. They define this to include: interjections (oh, uh-huh, Welcome), fillers (um, ah), and discourse markers (well, like, actually, but not you know). Iguazu is in Argentina :) discourse(is-2, :)-5)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#csubjpass_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#csubjpass"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">csubjpass</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#csubjpass">
    <rdfs:label>csubjpass</rdfs:label>
    <rdfs:label xml:lang="en-gb">clausal passive subject</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A clausal passive subject is a clausal syntactic subject of a passive clause (or more generally, any voice where the proto-agent argument does not become the subject of the clause). In the example below, that she lied is the subject. That she lied was suspected by everyone csubjpass(suspected, lied)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#goeswith_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#goeswith"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">goeswith</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#goeswith">
    <rdfs:label xml:lang="en-gb">goes with</rdfs:label>
    <rdfs:label>goeswith</rdfs:label>
    <rdfs:comment xml:lang="en-gb">This relation links two parts of a word that are separated in text that is not well edited. The head is in some sense the “main” part, often the second part. They come here with out legal permission goeswith(out-5, with-4)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#det_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#det"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">det</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#det">
    <rdfs:label>det</rdfs:label>
    <rdfs:label xml:lang="en-gb">determiner</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The relation determiner (det) holds between a nominal head and itsdeterminer. Most commonly, a word of POS DET will have the relation det and vice versa. The known exceptions at present are: In some of the datasets, a possessive determiner like [en] my is currently given the POS tag DET but the relation nmod, so that it is parallel with other possessive constructions. This is not yet completely parallel across languages; in some languages, it is much more clear than in English how possessive determiners relate to adjectives, and the nmod relation is out of question. The man is here det(man, The) Which book do you prefer ? det(book, Which)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#xcomp_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#xcomp"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">xcomp</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#xcomp">
    <rdfs:label>xcomp</rdfs:label>
    <rdfs:label xml:lang="en-gb">open clausal complement</rdfs:label>
    <rdfs:comment xml:lang="en-gb">An open clausal complement (xcomp) of a verb or an adjective is a predicative or clausal complement without its own subject. The reference of the subject is necessarily determined by an argument external to the xcomp (normally by the object of the next higher clause, if there is one, or else by the subject of the next higher clause). This is often referred to as obligatory control. These clauses tend to be non-finite in many languages, but they can be finite as well. The name xcomp is borrowed from Lexical-Functional Grammar. He says that you like to swim xcomp(like, swim) Sue asked George to respond to her offer xcomp(asked, respond) You look great xcomp(look, great) I started to work there yesterday xcomp(started, work) I consider him a fool xcomp(consider, fool) I consider him honest xcomp(consider, honest) We expect them to change their minds xcomp(expect, change) Note that the above condition “without its own subject” does not mean that a clause is an xcomp just because its subject is not overt. The subject must be necessarily inherited from a fixed position in the higher clause. That is, there should be no available interpretation where the subject of the lower clause may be distinct from the specified role of the upper clause. In cases where the missing subject may or must be distinct from a fixed role in the higher clause, ccomp should be used instead, as below. This includes cases of arbitrary subjects and anaphoric control. The boss said to start digging ccomp(said, start) Pro-drop languages have clauses where the subject is not present as a separate word, yet it is inherently present (and often deducible from the form of the verb) and it does not depend on arguments from a higher clause. Thus in neither of the following two Czech examples is there any overt subject, yet only the second example contains an xcomp. Píšu , protože jsem to slíbil . \n I-write , because I-have it promised . advcl(Píšu, slíbil) advcl(I-write, promised) Slíbil jsem psát . \n Promised I-have to-write . xcomp(Slíbil, psát) xcomp(Promised, to-write) Secondary Predicates The xcomp relation is also used in constructions that are known as secondary predicates or predicatives. Examples: She declared the cake beautiful. She declared the cake a success. We could paraphrase the sentence using a subordinate clause: She declared that the cake was beautiful. There are two predicates mixed in one clause: 1. she declared something, and 2. the cake was beautiful (according to her opinion). The secondary predicate will be attached to the main predicate as an xcomp: She declared the cake beautiful . nsubj(declared, She) dobj(declared, cake) xcomp(declared, beautiful) In the enhanced representation, there is an additional subject link showing the secondary predication: She declared the cake beautiful . nsubj(declared, She) dobj(declared, cake) xcomp(declared, beautiful) nsubj(beautiful, cake) A Czech example: jmenovat někoho generálem \n to-appoint someone as-a-general dobj(jmenovat, někoho) xcomp(jmenovat, generálem) Remember that xcomp is used for core arguments of clausal predicates so it will not be used for other instances of secondary predication. For instance, in She entered the room sad we also have a double predication (she entered the room; she was sad). But sad is not a core argument of enter: leaving it out will neither affect grammaticality nor significantly alter the meaning of the verb. On the other hand, leaving out beautiful in she declared the cake beautiful will either render the sentence ungrammatical or lead to a different interpretation of declared.The result is that in She entered the room sad, sad will depend on She and the relation will beacl instead of xcomp.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#reparandum_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#reparandum"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">reparandum</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#reparandum">
    <rdfs:label>reparandum</rdfs:label>
    <rdfs:label xml:lang="en-gb">overridden disfluency</rdfs:label>
    <rdfs:comment xml:lang="en-gb">We use reparandum to indicate disfluencies overridden in a speech repair. The disfluency is the dependent of the repair. Go to the righ- to the left . nmod(Go-1, left-7) reparandum(left-7, righ-) case(righ-, to-2) det(righ-, the-3) case(left-7, to-5) det(left-7, the-6)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#advmod_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#advmod"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">advmod</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#advmod">
    <rdfs:label>advmod</rdfs:label>
    <rdfs:label xml:lang="en-gb">adverbial modifier</rdfs:label>
    <rdfs:comment xml:lang="en-gb">An adverbial modifier of a word is a (non-clausal)adverb or adverbial phrase that serves to modify the meaning of the word. Note that in some grammatical traditions, the term adverbial modifier covers constituents that function like adverbs regardless whether they are realized by adverbs, adpositional phrases, or nouns in particular morphological cases. We differentiate adverbials realized as adverbs (advmod) and adverbials realized by noun phrases or adpositional phrases (nmod). Genetically modified food advmod(modified, Genetically) less often advmod(often, less) Where/ADV do/AUX you/PRON want/VERB to/ADP go/VERB later/ADV ?/PUNCT advmod(go, Where) advmod(go, later) About 200 people came to the party advmod(200, About)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#advcl_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#advcl"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">advcl</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#advcl">
    <rdfs:label xml:lang="en-gb">adverbial clause modifier</rdfs:label>
    <rdfs:label>advcl</rdfs:label>
    <rdfs:comment xml:lang="en-gb">An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.), as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose clause, etc. The dependent must be clausal (or else it is anadvmod) and the dependent is the main predicate of the clause. The accident happened as night was falling advcl(happened, falling) If you know who did it, you should tell the teacher advcl(tell, know) He talked to him in order to secure the account advcl(talked, secure) He was upset when I talked to him advcl(upset, talked)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#appos_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#appos"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">appos</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#appos">
    <rdfs:label xml:lang="en-gb">appositional modifier</rdfs:label>
    <rdfs:label>appos</rdfs:label>
    <rdfs:comment xml:lang="en-gb">An appositional modifier of a noun is a nominal immediately following the first noun that serves to define or modify that noun. It includes parenthesized examples, as well as defining abbreviations in one of these structures. Sam , my brother , arrived appos(Sam-1, brother-4) Bill ( John 's cousin ) appos(Bill-1, cousin-5) The Australian Broadcasting Corporation ( ABC ) appos(Corporation-4, ABC-6) In case of more than one appositive nominal, all nouns should be marked as modifying the first noun, rather than being chained: Sam , my brother , John 's cousin , arrived appos(Sam-1, brother-4) appos(Sam-1, cousin-8) Note however that nested apposition cannot be completely excluded. It may occur in combination with coordination: You can choose between four subjects : language ( German or French ) , economy , technology and art . appos(subjects, language) conj(language, economy) conj(language, technology) conj(language, art) cc(language, and) appos(language, German) conj(German, French) cc(German, or)appos is also used to link key-value pairs in addresses, signatures, etc. (see also thelist label): Steve Jones Phone: 555-9814 Email: jones@abc.edf name(Steve-1, Jones-2) list(Steve-1, Phone:-3) list(Steve-1, Email:-5) appos(Phone:-3, 555-9814-4) appos(Email:-5, jones@abc.edf-6)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#root_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#root"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">root</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#root">
    <rdfs:label xml:lang="en-gb">root</rdfs:label>
    <rdfs:label>root</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The root grammatical relation points to the root of the sentence. A fake node ROOT is used as the governor. The ROOT node is indexed with 0, since the indexing of real words in the sentence starts at 1. ROOT I love French fries . root(ROOT, love) Note: The following rule is not part of the official UD guidelines version 1. But it has been agreed that it should become part of the future versions of the standard, and the treebanks since release 1.2 should follow it. There should be just one node with the root dependency relation in every tree. If the main predicate is not present (due to ellipsis) and there are multiple orphaned dependents, the leftmost dependent should be promoted to the head (root) position and the other orphans should be attached to it. ROOT And Robert the fourth place . root(ROOT, And) nsubj(And, Robert) dobj(And, place) punct(And, .) amod(place, fourth) det(place, the)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#cc_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#cc"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">cc</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#cc">
    <rdfs:label xml:lang="en-gb">coordinating conjunction</rdfs:label>
    <rdfs:label>cc</rdfs:label>
    <rdfs:comment xml:lang="en-gb">For more on coordination, see theconj relation. A cc is the relation between the first conjunct and the coordinating conjunction delimiting another conjunct. (Note: different dependency grammars have different treatments of coordination. We take the first conjunct as the head of the coordination.) Bill is big and honest cc(big, and) A coordinating conjunction may also appear at the beginning of a sentence. This is also called a cc, and it depends on the root predicate of the sentence. (In fact there is a coordination that spans multiple sentences. We cannot attach a word to the first conjunct because it is in another sentence. Thus we attach it to the first conjunct available in the current sentence: its main predicate.) And then we left . cc(left, And) We have apples , pears , oranges , and bananas . dobj(have, apples) conj(apples, pears) conj(apples, oranges) conj(apples, bananas) cc(apples, and) punct(apples, ,-4) punct(apples, ,-6) punct(apples, ,-8)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nummod_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#nummod"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">nummod</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nummod">
    <rdfs:label xml:lang="en-gb">numeric modifier</rdfs:label>
    <rdfs:label>nummod</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A numeric modifier of a noun is anynumber phrase that serves to modify the meaning of the noun with a quantity. Sam ate 3 sheep nummod(sheep, 3) Sam spent forty dollars nummod(dollars, forty) Sam spent $ 40 nummod($, 40) Note that indefinite quantifiers such as few, many are tagged u-pos/DET rather than u-pos/NUM. Therefore their relation to the quantified noun is not nummod but det: Sam ate many sheep det(sheep, many)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#dislocated_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dislocated"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">dislocated</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#dislocated">
    <rdfs:label xml:lang="en-gb">dislocated elements</rdfs:label>
    <rdfs:label>dislocated</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The dislocated relation is used for fronted or postposed elements that do not fulfill the usual core grammatical relations of a sentence. These elements often appear to be in the periphery of the sentence, and may be separated off with a comma intonation. It is used for fronted elements that introduce the topic of a sentence, as in the following Japanese and Greek examples. The dislocated element attaches to the head of the clause to which it belongs: 象 は 鼻 が 長い \n zoo wa hana ga naga-i \n elephant TOPIC nose SUBJ long-PRES dislocated(長い-5, 象-1) to jani ton kserume poli kala \n the John-Acc him know-1pl very well dislocated(kserume, jani)However, it would not be used for a topic-marked noun that is also the subject of the sentence; this would be annsubj. It is also used for postposed elements. The dislocated elements attach to the same governor as the dependent that they double for. Right dislocated elements are frequent in spoken languages. French and Greek examples follow. Il faut pas la manger , la plasticine \n It must not it eat , the playdough dobj(manger, la-4) dislocated(manger, plasticine) dobj(eat, it-13) dislocated(eat, playdough) ton kserume oli mas edho poli kala, to jani dislocated(kserume, jani)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nsubjpass_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#nsubjpass"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">nsubjpass</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nsubjpass">
    <rdfs:label xml:lang="en-gb">passive nominal subject</rdfs:label>
    <rdfs:label>nsubjpass</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A passive nominal subject is a noun phrase which is the syntactic subject of a passive clause (or more generally, any voice where the proto-agent argument does not become the subject of the clause). Dole was defeated by Clinton nsubjpass(defeated, Dole)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#name_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#name"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">name</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#name">
    <rdfs:label xml:lang="en-gb">name</rdfs:label>
    <rdfs:label>name</rdfs:label>
    <rdfs:comment xml:lang="en-gb">name is one of the three relations for compounding in UD (together withcompound and mwe). It is used for proper nouns constituted of multiple nominal elements. For example, name would be used between the words of Hillary Rodham Clinton, New York, or Carl XVI Gustaf but not to replace the usual relations in a phrasal or clausal name like The king of Sweden or the novels The Lord of the Rings and Captured By Aliens. Words joined by name should all be part of a minimal noun phrase; otherwise regular syntactic relations should be used. This is basically similar to the treatment of noun compounds with compound, except that in many cases parts of the name may be another nominal element such as an adjective (United Airlines). In general, names are annotated in a flat, head-initial structure, in which all words in the name modify the first one using the name label. Carl XVI Gustaf name(Carl-1, Gustaf-3) name(Carl-1, XVI-2) For organization names with clear syntactic modification structure, the dependencies should reflect the syntactic modification structure using regular syntactic relation, as in:. Natural Resources Conservation Service amod(Resources-2, Natural-1) compound(Conservation-3, Resources-2) compound(Service-4, Conservation-3) In addition, regular syntactic relations are used: (i) for a modifying determiner or (ii) to connect together the words of a description or name which involve embedded prepositional phrases, sentences, etc. Le Japon det(Japon-2, Le-1) Ludwig van Beethoven case(Beethoven, van) Miguel de Cervantes y Saavedra conj(Cervantes, Saavedra) cc(Cervantes, y) case(Cervantes, de) The king of Sweden det(king-2, The-1) nmod(king-2, Sweden-4) case(Sweden-4, of-3) Río de la Plata case(Plata-4, de-2) det(Plata-4, la-3) nmod(Río-1, Plata-4) In the case of proper entities named after people, e.g. Leland Stanford Jr. University, the name relation should only be used inside the person name, with the rest of the construction analyzed compositionally using normal syntactic relations: Leland Stanford Jr. University compound(University-4, Leland-1) name(Stanford-2, Leland-1) name(Jr.-3, Leland-1)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#iobj_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#iobj"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">iobj</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#iobj">
    <rdfs:label>iobj</rdfs:label>
    <rdfs:label xml:lang="en-gb">indirect object</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The indirect object of a verb is any nominal phrase that is a core argument of the verb but is not its subject ordirect object. The prototypical example is the recipient of ditransitive verbs of exchange: She gave me a raise iobj(gave, me) However, many languages allow other semantic roles as additional objects. The most common case is allowing benefactives, but some languages allow other roles. Examples include instruments, such as in the Kinyarwanda example below, or comitatives. At the other extreme, some languages lack all indirect objects. Umukoóbwa a-ra-andik-iish-a íbárúwa íkárámu \n girl 1-PRS-write-APPL-ASP letter pen dobj(a-ra-andik-iish-a, íbárúwa) iobj(a-ra-andik-iish-a, íkárámu) In languages distinguishing morphological cases, the indirect object will often be marked by the dative case. However, verb valency may occasionally dictate that the direct object is in dative, or that the indirect objects shall take various other forms. In the following Czech example, the verb takes two arguments, both are nouns in the accusative case. One of them is direct object (patient), the other is indirect (addressee). It is parallel to how the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving (consider a similar sentence, he gave my daughter a class of maths). On učí mou dceru matematiku . \n He teaches my daughter.Acc maths.Acc . dobj(učí, matematiku) iobj(učí, dceru) dobj(teaches, maths.Acc) iobj(teaches, daughter.Acc) In general, if there is just one object, it should be labeled dobj, regardless of the morphological case or semantic role. For example, in English, teach can take either the subject matter or the recipient as the only object, and in both cases it would be analyzed ad the dobj: She teaches introductory logic dobj(teaches, logic) She teaches the first-year students dobj(teaches, students) This is consistent with the analysis of Huddleston and Pullum (2002) “The Cambridge Grammar of the English Language”, chapter 4 section 4 (p. 251). As they note, it is no different to the same semantic role being sometimes the subject and sometimes the object in intransitive/transitive alternations. The one exception is when there is a clausal complement. Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj, parallel to the simple ditransitive case: She told the students that they needed to study this evening iobj(told, students) ccomp(told, needed) She told the students the plan iobj(told, students) dobj(told, plan) If there are two or more objects, one of them should be dobj and the others should be iobj. In such cases it is necessary to decide what is the most directly affected object (patient). If possible, language-specific documentation should help identify direct and indirect objects.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nmod_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#nmod"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">nmod</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#nmod">
    <rdfs:label xml:lang="en-gb">nominal modifier</rdfs:label>
    <rdfs:label>nmod</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The nmod relation is used for nominal modifiers. They depend either on another noun (group “noun dependents”) or on a predicate (group “non-core dependents of clausal predicates”).nmod is anoun (or noun phrase) functioning as a non-core (oblique) argument or adjunct. This means that it functionally corresponds to an adverbial when it attaches to a verb, adjective or other adverb. But when attaching to a noun, it corresponds to an attribute, or genitive complement (the terms are less standardized here). The nmod relation can be further specified by the case. In conjunction with the case relation, it provides a uniform analysis for: the possessive alternation: the Chair 's office det(Chair-2, the-1) nmod(office-4, Chair-2) case(Chair-2, 's-3) the office of the Chair det(office-2, the-1) nmod(office-2, Chair-5) case(Chair-5, of-3) det(Chair-5, the-4) variant forms with case, a preposition or a postposition, as in Finnish for example: etsiä ilman johtolankaa \n to_search without clue.PARTITIVE nmod(etsiä, johtolankaa) case(johtolankaa, ilman) etsiä taskulampun kanssa \n to_search torch.GENITIVE with nmod(etsiä, taskulampun) case(taskulampun, kanssa) etsiä johtolangatta \n to_search clue.ABESSIVE nmod(etsiä, johtolangatta) the dative alternation where the prepositional construction gets a similar analysis to the double object construction: give the children the toys dobj(give, toys) iobj(give, children) give the toys to the children dobj(give, toys) nmod(give, children) case(children, to) # give the toys to the children 1 donner donner VERB _ VerbForm=Inf 0 root _ give 2 les le DET _ Definite=Def|Number=Plur 3 det _ the 3 jouets jouet NOUN _ Gender=Masc|Number=Plur 1 dobj _ toys 4-5 aux _ _ _ _ _ _ _ _ 4 à à ADP _ _ 6 case _ to 5 les le DET _ Definite=Def|Number=Plur 6 det _ the 6 enfants enfant NOUN _ Gender=Masc|Number=Plur 1 nmod _ children nmod is also used for temporal nominal modifiers: Last night , I swam in the pool nmod(swam, night)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#amod_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#amod"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">amod</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#amod">
    <rdfs:label>amod</rdfs:label>
    <rdfs:label xml:lang="en-gb">adjectival modifier</rdfs:label>
    <rdfs:comment xml:lang="en-gb">An adjectival modifier of a noun is any adjectival phrase that serves to modify the meaning of the noun. Sam eats red meat amod(meat, red) Sam took out a 3 million dollar loan amod(loan, dollar) Sam took out a $ 3 million loan amod(loan, $)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  <owl:Ontology rdf:about="http://fginter.github.io/docs/u/dep/">
    <owl:versionInfo xml:lang="en-gb">The inventory of dependency relations is adapted from Universal Stanford Dependencies: A cross-linguistic typology (de Marneffe et al. 2014). There have been modifications in the relations: we now have 40 universal relations (instead of the 42 ones proposed in the paper).</owl:versionInfo>
  </owl:Ontology>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#expl_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#expl"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">expl</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#expl">
    <rdfs:label>expl</rdfs:label>
    <rdfs:label xml:lang="en-gb">expletive</rdfs:label>
    <rdfs:comment xml:lang="en-gb">This relation captures expletive or pleonastic nominals. These are nominals that appear in an argument position of a predicate but which do not themselves satisfy any of the semantic roles of the predicate. The main predicate of the clause (the verb or predicate adjective or noun) is the governor. In English, this is the case for some uses of it and there: the existential there, and it when used in extraposition constructions. (Note that both it and there also have non-expletive uses.) There is a ghost in the room expl(is, There) It is clear that we should decline . expl(clear, It) Some languages do not have expletives of the English sort, including most languages with free pro-drop (the ability to use zero anaphora rather than overt pronouns). In languages with expletives of this sort, they can be positioned where normally a core argument appears: the subject and direct object (and even indirect object) slots, as in the examples below. Note that in the analysis of these examples, we treat the postposed subject or clausal argument as a regular core argument, and mark the expletive with expl. There is a ghost in the room expl(is, There) nsubj(is, ghost) nmod(is, room) I believe there to be a ghost in the room nsubj(believe, I) expl(believe, there) xcomp(believe, be) nsubj(be, ghost) nmod(be, room) It is clear that we should decline . expl(clear, It) csubj(clear, decline) That we should decline is clear . csubj(clear, decline) I mentioned it to Mary that Sue is leaving nsubj(mentioned, I) expl(mentioned, it) nmod(mentioned, Mary) ccomp(mentioned, leaving)A second, related, use of the expl relation is for cases of true clitic doubling. For languages in which clitics and lexical nominals are ususally in complementary distribution – languages, such as French, which obey “Kayne’s generalization” – then whichever of a clitic or a lexical nominal occurs will get the appropriate role, such as dobj or iobj. In such languages, when doubling does occur, such as in spoken French, the right analysis is to regard the lexical nominal asdislocated (see the examples there). However, other languages, such as Greek and Bulgarian, standardly allow doubling of a lexical nominal and a pronominal clitic, with the former still appearing in its regular role as an argument of the predicate. In these cases, if only one of the lexical nominal and the clitic appear in a clause, then whichever appears will be given the grammatical role of dobj, iobj, etc. – parallel to the treatment of lexical nominals and pronouns in other languages, modulo the clitic pronoun having a different position in the sentence. However, if both occur, the lexical nominal will be given the grammatical role of dobj, iobj, etc., and the clitic will be treated as a pronominal copy, which does not receive its own semantic role, and hence will get the role expl. Modulo the different word order, this is fairly parallel to the treatment of it and there in English mentioned above, where another phrase satisfies the semantic role of the predicate. Examples from Greek and Bulgarian follow: Της τον έδωσε της Καίτης τον αναπτήρα \n PRON.Fem.Gen PRON.Masc.Acc gave ART.Fem.Gen Keti.Gen ART.Masc.Acc lighter.Acc expl(έδωσε, Της-1) iobj(έδωσε, Καίτης) det(Καίτης, της-4) expl(έδωσε, τον-2) dobj(έδωσε, αναπτήρα) det(αναπτήρα, τον-6) Marija mu izprati pismo na rabotnika \n Maria 3.S.M.IO sent letter to the.worker expl(izprati, mu) dobj(izprati, pismo) iobj(izprati, rabotnika) case(rabotnika, na) The expletive relation is also used for reflexive pronouns (see the feature u-feat/Reflex) attached to inherently reflexive verbs, i.e. verbs that cannot occur without the reflexive pronoun and thus the pronoun does not play the role of a normal object (otherwise it would be possible to substitute it with an irreflexive pronoun or other nominal). A Czech example: Martin se bojí zvířat . \n Martin REFLEX fears animals . expl(bojí, se) expl(fears, REFLEX) Further general discussion of expletives can be found in Postal, P. M., and G. K. Pullum (1988) “Expletive Noun Phrases in Subcategorized Positions,” Linguistic Inquiry 19(4): 635–670. The status of clitic doubling, and arguments for the lexical nominal being an argument with the clitic a kind of pronominal copy, appear inter alia in Boris Harizanov (2014) Clitic doubling at the syntax-morphology interface: A-movement and morphological merger in Bulgarian. Natural Language and Linguistic Theory.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#punct_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#punct"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">punct</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#punct">
    <rdfs:label xml:lang="en-gb">punctuation</rdfs:label>
    <rdfs:label>punct</rdfs:label>
    <rdfs:comment xml:lang="en-gb">This is used for any piece of punctuation in a clause, if punctuation is being retained in the typed dependencies. Go home ! punct(Go, !)Tokens with the relationu-dep/punct always attach to content words (except in cases of ellipsis) and can never have dependents. Since punct is not a normal dependency relation, the usual criteria for determining the head word do not apply. Instead, we use the following principles: A punctuation mark separating coordinated units is attached to the first conjunct. A punctuation mark preceding or following a subordinated unit is attached to this unit. Within the relevant unit, a punctuation mark is attached at the highest possible node that preserves projectivity. Paired punctuation marks (quotes and brackets) should be attached to the same word unless that would create non-projectivity. This word is usually the head of the phrase enclosed in the paired punctuation. We have apples , pears , oranges , and bananas . dobj(have, apples) conj(apples, pears) conj(apples, oranges) conj(apples, bananas) cc(apples, and) punct(apples, ,-4) punct(apples, ,-6) punct(apples, ,-8) Der Mann , den Sie gestern kennengelernt haben , kam wieder . punct(kennengelernt, ,-3) punct(kennengelernt, ,-9) punct(kam, .) A.K.A. , AKA , or a\/k\/a may refer to : “ Also known as ” , used to introduce pseudonyms , aliases , etc. ( Compare f.k.a. for “ formerly known as ” . ) punct(A.K.A., ,-2) punct(A.K.A., ,-4) punct(refer, :) punct(known-13, “-11) punct(known-13, ”-15) punct(used, ,-16) punct(pseudonyms, ,-21) punct(pseudonyms, ,-23) punct(Compare, (-25) punct(Compare, )-35) punct(known-31, “-29) punct(known-31, ”-33) punct(Compare, .-34)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#parataxis_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#parataxis"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">parataxis</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#parataxis">
    <rdfs:label>parataxis</rdfs:label>
    <rdfs:label xml:lang="en-gb">parataxis</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The parataxis relation (from Greek for “place side by side”) is a relation between a word (often the main predicate of a sentence) and other elements, such as a sentential parenthetical or a clause after a “:” or a “;”, placed side by side without any explicit coordination, subordination, or argument relation with the head word. Parataxis is a discourse-like equivalent of coordination, and so usually obeys an iconic ordering. Hence it is normal for the first part of a sentence to be the head and the second part to be the parataxis dependent, regardless of the headedness properties of the language. But things do get more complicated, such as cases of parentheticals, which appear medially. Let 's face it we 're annoyed parataxis(Let, annoyed) The guy , John said , left early in the morning parataxis(left, said) An inventory of constructions to which parataxis has been applied Side-by-side sentences (“run-on sentences”) The relation parataxis is used for a pair of what could have been standalone sentences, but which are being treated together as a single sentence. This may happen because sentence segmentation of the sentence was done primarily following the presence of sentence-final punctuation, and these clauses are joined by punctuation such as a colon or comma, or not delimited by punctuation at all. In a spoken corpus, it may happen because what is labeled as a sentence is more commonly an utterance turn. Even if the treebanker is doing the sentence division, it may happen because there seems to be a clear discourse relation linking two clauses. Sometimes there are more than two sentences joined in this way. In this case we make all the later sentences dependents of the first one, to maximize similarity to the analysis used for conjunction. Bearded dragons are sight hunters , they need to see the food to move . parataxis(hunters, need) This relation may happen with units that are smaller than sentences: Divided world the CIA amod(world, Divided) parataxis(world, CIA) det(CIA, the) Treatment of reported speech For this reported speech example: The guy , John said , left early in the morning parataxis(left, said)there are paraphrases that convey essentially the same meaning but with a different syntactic structure. When the reported speech is embedded in a subordinate clause (with or without an overt complementizer that), the subordinate clause is accomp of the speech verb. When the reported speech follows the speech verb and is separated by a colon, the reported speech forms a main clause that attaches to the preceding main clause with a parataxis relation, hence with the speech verb as its head. However, when the speech verb occurs as a medial or final parenthetical, the relation is reversed and the speech verb is treated as a parataxis of the reported speech. This analysis is not uncontroversial but follows many authorities, such as Huddleston and Pullum (2002), The Cambridge Grammar of the English Language (see chapter 11, section 9). John said that the guy left early in the morning . ccomp(said, left) John said the guy left early in the morning . ccomp(said, left) John said : “ The guy left early in the morning . ” parataxis(said, left) “ The guy left early in the morning ” , John said . parataxis(left, said) The guy left early in the morning , John said . parataxis(left, said) The guy , he said , left early in the morning . parataxis(left, said) An argument for this analysis is that in the cases analyzed as embedding, the entire clause can be further embedded (I was taken aback when John said the guy left early in the morning.), while this is not possible with medial or final placement of the speech verb (*I was taken aback when the guy left early this morning, John said.). News article bylines We have used the parataxis relation to connect the parts of a news article byline. There does not seem to be a better relation to use. Washington ( CNN ) : parataxis(Washington, CNN) Interjected clauses Single word or phrase interjections are analyzed as discourse, but when a whole clause is interjected, we use the relation parataxis. Calafia has great fries ( they are to die for ! ) parataxis(has, are) Just to let you all know Matt has confirmed the booking for 3rd Dec is OK . parataxis(confirmed, let) In the second example, we treat the second half as the head of the dependency because the first half feels like a whole clause interjection, not like the main clause of the utterance. Tag questions We also use the parataxis relation for tag questions such as isn’t it? or haven’t you?. It 's not me , is it ? parataxis(me, is)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#list_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#list"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">list</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#list">
    <rdfs:label xml:lang="en-gb">list</rdfs:label>
    <rdfs:label>list</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The list relation is used for chains of comparable items. In lists with more than two items, all items of the list should modify the first one. Informal and web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures often contain these structures, in the form of contact information: the different contact information items are labeled as list; the key-value pair relations are labeled asappos. Steve Jones Phone: 555-9814 Email: jones@abc.edf name(Steve-1, Jones-2) list(Steve-1, Phone:-3) list(Steve-1, Email:-5) appos(Phone:-3, 555-9814-4) appos(Email:-5, jones@abc.edf-6) Another place where list has been used is for a sequence of attributes or descriptive terms used as the title line of a review (such as product or restaurant reviews, etc.: Long Lines , Silly Rules , Rude Staff , Ok Food list(Lines, Rules) list(Lines, Staff) list(Lines, Food) However, list should not be over-used. If a construction can be easily analyzed using the grammatical relations of standard sentences, such as when there is overt coordination, then it should be analyzed with these more standard relations, even if it is laid out as a list typographically.</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#vocative_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#vocative"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">vocative</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#vocative">
    <rdfs:label>vocative</rdfs:label>
    <rdfs:label xml:lang="en-gb">vocative</rdfs:label>
    <rdfs:comment xml:lang="en-gb">The vocative relation is used to mark a dialogue participant addressed in a text (common in conversations, dialogue, emails, newsgroup postings, etc.). The relation links the addressee’s name to its host sentence. A vocative commonly co-occurs with a null subject, as in the first example below. If the nominal is clearly vocative in intent, the preference is to use the vocative relation. Guys , take it easy! vocative(take, Guys) Marie , comment vas - tu ? vocative(vas, Marie)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
  
<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#cop_inst">
<rdf:type rdf:resource="http://fginter.github.io/docs/u/dep/all.html#cop"/>
<oliasystem:hasTag rdf:datatype="&xsd;string">cop</oliasystem:hasTag>
</rdf:Description>

<rdf:Description rdf:about="http://fginter.github.io/docs/u/dep/all.html#cop">
    <rdfs:label>cop</rdfs:label>
    <rdfs:label xml:lang="en-gb">copula</rdfs:label>
    <rdfs:comment xml:lang="en-gb">A copula is the relation between the complement of a copular verb and the copular verb to be (only). (We normally take a copula as a dependent of its complement.) Bill is honest nsubj(honest, Bill) cop(honest, is) Ivan is the best dancer nsubj(dancer-5, Ivan-1) cop(dancer-5, is-2) det(dancer-5, the-3) amod(dancer-5, best-4) The copula be is not treated as the head of a clause, but rather the dependent of a lexical predicate, as exemplified above. Such an analysis is motivated by the fact that many languages often or always lack an overt copula in such constructions, as in the the following Russian example: Ivan lučšij tancor \n Ivan best dancer nsubj(tancor, Ivan) amod(tancor, lučšij) In informal English, this may also arise. Email usually free if you have Wifi. nsubj(free, Email) This analysis is adopted also when the predicate is a prepositional phrase, in which case the nominal part of the prepositional phrase is the head of the clause. Sue is in shape nsubj(shape, Sue) cop(shape, is) case(shape, in) A parallel can also be drawn to so-called raising-to-object or small clause constructions in English. Under the basic analysis proposed for SD, the predicate complement is not linked to its subject argument, but in the enhanced representation (see below), the linkage is then parallel to the treatment in a zero copula language: I judge Ivan the best dancer nsubj(judge-2, I-1) dobj(judge-2, Ivan-3) xcomp(judge-2, dancer-6) det(dancer-6, the-4) amod(dancer-6, best-5) nsubj(dancer-6, Ivan-3) If the copula is accompanied by other verbal auxiliaries for tense, aspect, etc., then they are also given a flat structure, and taken as dependents of the lexical predicate: Sue has been helpful nsubj(helpful, Sue) cop(helpful, been) aux(helpful, has) The motivation for this choice is that this structure is parallel to the flat structure which we give to auxiliary verbs accompanying verbs. In particular, in languages such as English, it is often very difficult to decide whether to regard a participle as a verb or an adjective. Perhaps the following sentence is such a case: The presence of troops will be destabilizing . nsubj(destabilizing, presence) cop(destabilizing, be) aux(destabilizing, will) While a part of speech has to be decided in such cases, it would be unfortunate if the choice of part of speech also changed the dependency structure. Finally, ccomp is used with copulas. Only in this case, the structure is different, and we take the form of be as a head: The important thing is to keep calm . ccomp(is, keep) nsubj(is, thing) The problem is that this has never been tried . ccomp(is, tried) nsubj(is, problem) If we took the main verb as the head, it would have two subjects, which would be unworkable. Examples like the above could be analyzed reversed with the initial noun phrase as the predicate, but in addition to this seeming undesirable, it would fail to be a solution if there were a clause on both sides of be, such as in: (For us) to not attempt to solve the problem is (for us) to acknowledge defeat. (Note: This solution is awkward and refining it is a possible direction for the future; the original Finnish TDT was done differently and it may be worth considering their solution.)</rdfs:comment>
    <rdfs:subClassOf rdf:resource="http://fginter.github.io/docs/u/dep/all.html#dep"/>
  </rdf:Description>
</rdf:RDF>

